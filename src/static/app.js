document.addEventListener('DOMContentLoaded', () => {
    const recordBtn = document.getElementById('record-btn');
    const readScreenToggle = document.getElementById('read-screen-toggle');
    const statusIndicator = document.getElementById('status-indicator');
    const transcriptionText = document.getElementById('transcription-text');
    const answerText = document.getElementById('answer-text');
    const playbackAudio = document.getElementById('playback-audio');
    const activeModelName = document.getElementById('active-model-name');
    const chatModeToggle = document.getElementById('chat-mode-toggle');
    const documentList = document.getElementById('document-list');

    let mediaRecorder;
    let audioChunks = [];
    let isRecording = false;

    // Initialize MediaRecorder
    async function setupAudio() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = event => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = processAudio;
        } catch (err) {
            console.error("Error accessing microphone:", err);
            statusIndicator.textContent = "Error: Microphone access denied.";
            statusIndicator.style.color = "#ef4444";
            recordBtn.disabled = true;
        }
    }

    // Pointer events for mobile/desktop unified holding
    recordBtn.addEventListener('pointerdown', startRecording);
    recordBtn.addEventListener('pointerup', stopRecording);
    recordBtn.addEventListener('pointerleave', stopRecording); // Stop if cursor leaves while holding

    function startRecording(e) {
        if (!mediaRecorder || isRecording) return;

        // Prevent generic mobile actions while holding
        if (e) e.preventDefault();

        audioChunks = [];
        mediaRecorder.start();
        isRecording = true;

        recordBtn.classList.add('recording');
        recordBtn.textContent = "Recording... Release to Send";
        statusIndicator.textContent = "Listening...";
        statusIndicator.style.color = "#ff4b2b";

        // Reset UI
        transcriptionText.textContent = "Analyzing audio...";
        transcriptionText.classList.add("placeholder");
        answerText.textContent = "Awaiting transcription...";
        answerText.classList.add("placeholder");

        // Stop current audio if playing
        playbackAudio.pause();
    }

    function stopRecording() {
        if (!mediaRecorder || !isRecording) return;

        mediaRecorder.stop();
        isRecording = false;

        recordBtn.classList.remove('recording');
        recordBtn.textContent = "Hold to Speak";
        statusIndicator.textContent = "Processing... Please wait (this may take a minute).";
        statusIndicator.style.color = "#fbbf24";
    }

    async function processAudio() {
        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
        const formData = new FormData();
        formData.append('file', audioBlob, 'query.wav');

        // Check toggles
        if (readScreenToggle.checked) {
            formData.append('read_screen', 'true');
        }
        if (chatModeToggle.checked) {
            formData.append('chat_mode', 'true');
        }

        try {
            const response = await fetch('/ask_voice', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errData = await response.json();
                throw new Error(errData.detail || "Server error");
            }

            const data = await response.json();

            // Update UI
            transcriptionText.textContent = data.transcription;
            transcriptionText.classList.remove("placeholder");

            answerText.textContent = data.answer;
            answerText.classList.remove("placeholder");

            statusIndicator.textContent = "Success! Playing response...";
            statusIndicator.style.color = "#10b981";

            // Play Audio
            if (data.audio_base64) {
                playbackAudio.src = `data:audio/wav;base64,${data.audio_base64}`;
                playbackAudio.play().catch(e => console.error("Audio playback error:", e));
            } else {
                statusIndicator.textContent = "No audio generated by server.";
            }

            setTimeout(() => {
                statusIndicator.textContent = "Ready";
                statusIndicator.style.color = "#94a3b8";
            }, 3000);

        } catch (error) {
            console.error("Pipeline Error:", error);
            statusIndicator.textContent = `Error: ${error.message}`;
            statusIndicator.style.color = "#ef4444";
            transcriptionText.textContent = "Failed to process.";
            answerText.textContent = "Failed to process.";
        }
    }

    async function fetchHealth() {
        try {
            const res = await fetch('/health');
            const data = await res.json();
            if (activeModelName && data.models && data.models.llm) {
                activeModelName.textContent = data.models.llm;
            }
        } catch (e) {
            console.error("Failed to fetch health info", e);
            if (activeModelName) activeModelName.textContent = "Offline";
        }
    }

    async function fetchDocuments() {
        if (!documentList) return;
        try {
            const res = await fetch('/documents');
            const data = await res.json();

            if (data.documents.length === 0) {
                documentList.innerHTML = '<p class="placeholder">No documents uploaded.</p>';
                return;
            }

            documentList.innerHTML = '';
            data.documents.forEach(doc => {
                const docEl = document.createElement('div');
                docEl.className = 'doc-item';
                docEl.innerHTML = `
                    <span class="doc-name">ðŸ“„ ${doc.filename}</span>
                    <button class="delete-btn" data-id="${doc.doc_id}">Trash</button>
                `;
                documentList.appendChild(docEl);
            });

            // Attach delete listeners
            documentList.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const id = e.target.getAttribute('data-id');
                    if (confirm('Are you sure you want to delete this document?')) {
                        await deleteDocument(id);
                    }
                });
            });
        } catch (e) {
            console.error("Failed to fetch documents", e);
            documentList.innerHTML = '<p class="placeholder" style="color:red">Error loading documents.</p>';
        }
    }

    async function deleteDocument(doc_id) {
        try {
            const res = await fetch(`/document/${doc_id}`, { method: 'DELETE' });
            if (res.ok) {
                fetchDocuments(); // refresh list
            } else {
                alert("Failed to delete document.");
            }
        } catch (e) {
            console.error("Delete err:", e);
        }
    }

    // Initialize on load
    setupAudio();
    fetchHealth();
    fetchDocuments();

    // Refresh health after queries as the model might swap
    chatModeToggle.addEventListener('change', fetchHealth);
});
